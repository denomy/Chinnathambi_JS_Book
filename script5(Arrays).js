/* Массивы в JS*/

let ingredients = ["Молоко", "Хлеб", "Яйца", "Сок", "Колбаса"];
alert(ingredients[1]);

document.writeln("Начальный массив c размером " + ingredients.length + ": ");
for (let i = 0; i < ingredients.length; i++) {
    document.writeln(ingredients[i]);
}

/* push добавляет в конец массива */
ingredients.push("Помидор");
alert(ingredients[5]);

/* unshift добавляет в начало массива на позицию [0], но это плохо так как деняются все индексы и это долго */
ingredients.unshift("Банан");
alert(ingredients[0]);

/* push  unshift возвращают новый размер массива при добавлении */
let arrayLenght = ingredients.push("САХАР");
document.writeln("<br>" + "Сейчас размер массива = " + arrayLenght + ": ");
for (let i = 0; i < ingredients.length; i++) {
    document.writeln(ingredients[i]);
}

let good = ["Mario", "Luigi", "Kirby", "Yoshi"];
let bad = ["Bowser", "Koopa Troopa", "Goomba"];
let goodAndBad = good.concat(bad);
console.log(goodAndBad);


/* Изменение каждого элемента
с помощью for, т.е изменение итерационно */

/* Обратите внимание, что мы перебираем каждый элемент, делаем первую
букву заглавной и добавляем исправленное имя в новый массив newNames.
Здесь нет ничего магического или сложного, но вы будете часто брать
элементы массива, изменять их (или обращаться к ним) и возвращать
новый массив с измененными данными. Это достаточно тривиальная за-
дача, где задействуется много рутинного повторяющегося кода. В боль-
ших кодовых базах разбор происходящего в цикле добавляет ненужные
хлопоты. Вот почему были введены методы map, filter и reduce. С их
помощью вы получаете все возможности цикла for без ненужных по-
бочных эффектов и лишнего кода. Кому бы это не понравилось? */
let names = ["marge", "homer", "bart", "lisa", "maggie"];

let newNames = [];

for (let i = 0; i < names.length; i++) {
    let name = names[i];
    let firstLetter = name.charAt(0).toUpperCase();
    newNames.push(firstLetter + name.slice(1));
}

console.log(newNames);


/* Изменение каждого элемента
с помощью map т.е по крутому*/

/* Разберемся, как этот код работает. Нас интересует функция capita-
lize ItUp, переданная в виде аргумента методу map. Эта функция выпол-
няется для каждого элемента, и стоит обратить внимание, что текущий
элемент передается ей в качестве аргумента. Для ссылки на аргумент
текущего элемента вы можете использовать любое имя на ваш выбор.
Мы ссылаемся на этот аргумент с помощью банального item: */
let names1 = ["marge", "homer", "bart", "lisa", "maggie"];

/* ФУНКЦИИ ОБРАТНЫХ ВЫЗОВОВ
Наша функция capitalizeItUp также известна как функция обратного
вызова (call back function). Такие функции подразумевают два действия:
- передачу в качестве аргумента другой функции;
- вызов из другой функции. */
function capitalizeItUp(item) {
    let firstLetter = item.charAt(0).toUpperCase();
    return firstLetter + item.slice(1);
}

let newNames1 = names1.map(capitalizeItUp);
console.log(newNames1);

/* Фильтрация элементов массива */
let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];

let evenNumbers = numbers.filter(function (item) { // применяем анонимную (без имени) колбэк функцию!!!!
    return (item % 2 == 0); // return здесь возвращает true если передаваемое число четное и false если нечетное!!!!!
});

console.log(evenNumbers);

/* Подробнее об аргументах функций обратных вызовов
Для методов map и  filter в  наших функциях обратных вызовов мы
определяли только один аргумент, представляющий текущий элемент
массива. Для метода reduce мы определяли два аргумента, представ-
лявших итоговое значение и текущий элемент. Помимо этого, функции
обратных вызовов имеют два опциональных аргумента, которые вы
также можете определить:
y индекс текущего элемента массива;
y массив, для которого вызывается map, filter или reduce.
Для методов map и filter эти аргументы стали бы вторым и третьим.
Для reduce они бы оказались третьим и четвертым. Вы можете никог-
да не столкнуться с  необходимостью определять эти опциональные
аргументы, но если они все же вам понадобятся, знайте, где их искать.
Мы почти закончили. Давайте взглянем на пример, где показана работа
метода reduce с нечисленными значениями: */

let words = ["Where", "do", "you", "want", "to", "go", "today?"];

let phrase = words.reduce(function (total, current, index) {
    if (index == 0) {
        return current;
    } else {
        return total + " " + current;
    }
}, "");

console.log(phrase);